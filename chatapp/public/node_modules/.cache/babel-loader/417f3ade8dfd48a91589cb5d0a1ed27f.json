{"ast":null,"code":"import { sync } from '../../frameloop/index.mjs';\nimport { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\nfunction handoffOptimizedAppearAnimation(id, name, value) {\n  const {\n    MotionAppearAnimations\n  } = window;\n  const animationId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n  const animation = MotionAppearAnimations && MotionAppearAnimations.get(animationId);\n\n  if (animation) {\n    const sampledTime = performance.now();\n    /**\n     * Resync handoff animation with optimised animation.\n     *\n     * This step would be unnecessary if we triggered animateChanges() in useEffect,\n     * but due to potential hydration errors we currently fire them in useLayoutEffect.\n     *\n     * By the time we're safely ready to cancel the optimised WAAPI animation,\n     * the main thread might have been blocked and desynced the two animations.\n     *\n     * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\n     */\n\n    sync.update(() => {\n      if (value.animation) {\n        value.animation.currentTime = performance.now() - sampledTime;\n      }\n    });\n    /**\n     * We allow the animation to persist until the next frame:\n     *   1. So it continues to play until Framer Motion is ready to render\n     *      (avoiding a potential flash of the element's original state)\n     *   2. As all independent transforms share a single transform animation, stopping\n     *      it synchronously would prevent subsequent transforms from handing off.\n     */\n\n    sync.render(() => {\n      MotionAppearAnimations.delete(animationId);\n      /**\n       * Animation.cancel() throws so it needs to be wrapped in a try/catch\n       */\n\n      try {\n        animation.cancel();\n      } catch (e) {}\n    });\n    return animation.currentTime || 0;\n  } else {\n    return 0;\n  }\n}\n\nexport { handoffOptimizedAppearAnimation };","map":{"version":3,"names":["sync","transformProps","appearStoreId","handoffOptimizedAppearAnimation","id","name","value","MotionAppearAnimations","window","animationId","has","animation","get","sampledTime","performance","now","update","currentTime","render","delete","cancel","e"],"sources":["/Users/rajesh/Desktop/ChatApp/reactchatapp/public/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs"],"sourcesContent":["import { sync } from '../../frameloop/index.mjs';\nimport { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\nfunction handoffOptimizedAppearAnimation(id, name, value) {\n    const { MotionAppearAnimations } = window;\n    const animationId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n    const animation = MotionAppearAnimations && MotionAppearAnimations.get(animationId);\n    if (animation) {\n        const sampledTime = performance.now();\n        /**\n         * Resync handoff animation with optimised animation.\n         *\n         * This step would be unnecessary if we triggered animateChanges() in useEffect,\n         * but due to potential hydration errors we currently fire them in useLayoutEffect.\n         *\n         * By the time we're safely ready to cancel the optimised WAAPI animation,\n         * the main thread might have been blocked and desynced the two animations.\n         *\n         * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\n         */\n        sync.update(() => {\n            if (value.animation) {\n                value.animation.currentTime = performance.now() - sampledTime;\n            }\n        });\n        /**\n         * We allow the animation to persist until the next frame:\n         *   1. So it continues to play until Framer Motion is ready to render\n         *      (avoiding a potential flash of the element's original state)\n         *   2. As all independent transforms share a single transform animation, stopping\n         *      it synchronously would prevent subsequent transforms from handing off.\n         */\n        sync.render(() => {\n            MotionAppearAnimations.delete(animationId);\n            /**\n             * Animation.cancel() throws so it needs to be wrapped in a try/catch\n             */\n            try {\n                animation.cancel();\n            }\n            catch (e) { }\n        });\n        return animation.currentTime || 0;\n    }\n    else {\n        return 0;\n    }\n}\n\nexport { handoffOptimizedAppearAnimation };\n"],"mappings":"AAAA,SAASA,IAAT,QAAqB,2BAArB;AACA,SAASC,cAAT,QAA+B,uCAA/B;AACA,SAASC,aAAT,QAA8B,gBAA9B;;AAEA,SAASC,+BAAT,CAAyCC,EAAzC,EAA6CC,IAA7C,EAAmDC,KAAnD,EAA0D;EACtD,MAAM;IAAEC;EAAF,IAA6BC,MAAnC;EACA,MAAMC,WAAW,GAAGP,aAAa,CAACE,EAAD,EAAKH,cAAc,CAACS,GAAf,CAAmBL,IAAnB,IAA2B,WAA3B,GAAyCA,IAA9C,CAAjC;EACA,MAAMM,SAAS,GAAGJ,sBAAsB,IAAIA,sBAAsB,CAACK,GAAvB,CAA2BH,WAA3B,CAA5C;;EACA,IAAIE,SAAJ,EAAe;IACX,MAAME,WAAW,GAAGC,WAAW,CAACC,GAAZ,EAApB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQf,IAAI,CAACgB,MAAL,CAAY,MAAM;MACd,IAAIV,KAAK,CAACK,SAAV,EAAqB;QACjBL,KAAK,CAACK,SAAN,CAAgBM,WAAhB,GAA8BH,WAAW,CAACC,GAAZ,KAAoBF,WAAlD;MACH;IACJ,CAJD;IAKA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQb,IAAI,CAACkB,MAAL,CAAY,MAAM;MACdX,sBAAsB,CAACY,MAAvB,CAA8BV,WAA9B;MACA;AACZ;AACA;;MACY,IAAI;QACAE,SAAS,CAACS,MAAV;MACH,CAFD,CAGA,OAAOC,CAAP,EAAU,CAAG;IAChB,CATD;IAUA,OAAOV,SAAS,CAACM,WAAV,IAAyB,CAAhC;EACH,CApCD,MAqCK;IACD,OAAO,CAAP;EACH;AACJ;;AAED,SAASd,+BAAT"},"metadata":{},"sourceType":"module"}